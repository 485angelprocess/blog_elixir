<html>
<head>
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/app.css">
  <script type="text/javascript" src="/assets/app.js"></script>
  <meta charset="UTF-8">
</head>
  <body>
    <div class="bg-linear-65 from-purple-500 to-pink-500">
    
  <a href="/../index.html">home</a>
  <h1>
Minimal Forth implementation in Rust</h1>
<p>
I have been looking at forth a bit and wanted to start putting together some implementations of it. The language is structured so that a minimal implementation is very quick to do. My overall goal is to make a non-portable RISC-V implementation, with a built-in editor, but for now I am doing a portable version with no editor. I used <a href="https://github.com/zevv/zForth">zforth</a> as a main reference, also looking at gforth and colorForth as references.</p>
<p>
A core to forth is an extensible dictionary of words, so I want to start setting up a rust struct to handle the state of the program, with the ability to run primitives, and do stack operations. To get things up and running I wanted to try to keep things as simple as possible. The data stack is a <code class="inline">Vec</code>. I map the dictionary words using a HashMap, this is close to the zforth implementation, but I’m trying to use some more idiomatic rust as well. The first pass at the core struct is:</p>
<pre><code class="rust">type  BaseType = i32;

pub struct Context{
    data_stack: Vec&lt;BaseType&gt;,
    dict: HashMap&lt;String, usize&gt;,
    prim: HashMap&lt;usize, PRIM&gt;
}</code></pre>
<p>
Pop and push operate on the stack:</p>
<pre><code class="rust">fn pop(&amp;mut self) -&gt; BaseType{
    self.data_stack.pop().unwrap()
}

fn push(&amp;mut self, v: BaseType){
    self.data_stack.push();
}</code></pre>
<p>
For now I’m populating the primitive dictionary at runtime. Literals and syscalls have specific rules for parsing, so I’m treating somewhat separately. This sets up a map from  an op number/address to a enum for the primitives. Later, I will add functionality for op numbers above the primitives for custom words. For now I just want to see a basic program running, so I’m only doing a few words:</p>
<pre><code class="rust">pub fn setup(&amp;mut self){
    self.lit = self.add_implicit(PRIM::LIT);
    self.sys = self.add_implicit(PRIM::SYS);

    self.add_prim(&quot;dup&quot;, PRIM::DUP);
    self.add_prim(&quot;*&quot;, PRIM::MUL);
}</code></pre>
<p>
My parser is starting as this. I am going to tidy this up later, but it gets the op number and an optional argument. I see reasons to treat the argument as an <code class="inline">Option</code> or a mutable reference, which I’ll decide on later.</p>
<pre><code class="rust">fn get_op(&amp;mut self, msg: &amp;String) -&gt; (usize, i32){

    if msg.starts_with(&quot;.&quot;){
        // System call/special functions
        if let Some(result) = msg.bytes().nth(1){
            // system call with specifier
            // These aren&#39;t implemented yet,
            // But .&quot; is literal string
            // and .s displays the entire stack as examples
            return (self.sys, result.try_into().unwrap());
        }
        else{
            // system call no argument
            return (self.sys, 0);
        }
    }
    if self.dict.contains_key(msg){
        // in dictionary of words
        return (self.dict[msg], 0);
    }
    // assume it is literal
    (self.lit, msg.parse().unwrap())
}</code></pre>
<p>
With the op number I can direct my interpreter to run a primitive or a custom word.</p>
<pre><code class="rust">pub fn parse(&amp;mut self, msg: &amp;String){

    // get address of word with argument
    let (op, v) = self.get_op(msg);

    if self.prim.contains_key(&amp;op){
        self.do_prim(self.prim[&amp;op], v);
    }
    else{
        todo!(&quot;Custom words not implemented yet.&quot;);
    }
}</code></pre>
<p>
Primitives are treated as a switch. Each primitive is intended to be very simple to implement.</p>
<pre><code class="rust">pub fn do_prim(&amp;mut self, p: PRIM, v: BaseType){
    match p{
        PRIM::LIT =&gt; self.push(v),
        PRIM::SYS =&gt; self.sys_call(v),
        PRIM::DUP =&gt; {
            // Duplicate the top of the stack
            let v = self.pop();
            self.push(v);
            self.push(v);
        },
        PRIM::MUL =&gt; {
            // Multiply the top 2 numbers on the stack
            let a = self.pop();
            let b = self.pop();
            self.push(a * b);
        },
        _ =&gt; todo!(&quot;Not implemented {:?}&quot;, p)
    }
}</code></pre>
<p>
With this setup, I can get my first extremely scoped program up. The program is:</p>
<pre><code class="forth">5 dup * .</code></pre>
<p>
This puts 5 on the stack, duplicates it, and the multiples, giving the square of 5. The <code class="inline">.</code> word pops the stack and prints the top value.</p>
<p>
The main function for my demo looks like:</p>
<pre><code class="rust">fn main() {
    let mut ctx = Context::new();

    ctx.setup();

    let program = &quot;5 dup * .&quot;;

    // go through program
    for p in program.split(&quot; &quot;){

        //println!(&quot;{}, {}&quot;, p.to_string(), p.len());
        ctx.parse(&amp;p.to_string());
    }
}</code></pre>
<p>
This runs, printing out 25.</p>
<h2>
Testing</h2>
<p>
Next I started going through and adding tests for the basic functionality I was looking for. I am going to add some more coverage later, but wanted to highlight some of the basic tests. <code class="inline">dup</code> is a core stack operation for forth. To start, it should panic when there is nothing in the stack:</p>
<pre><code class="rust">#[test]
#[should_panic]
fn dup_requires_argument(){
    let mut ctx = Context::new();
    run_program(&quot;dup .&quot;, &amp;mut ctx);
}</code></pre>
<p>
Next it should function, by duplicating the top of the stack:</p>
<pre><code class="rust">#[test]
fn dup(){
    let mut ctx = Context::new();
    run_program(&quot;5 dup . .&quot;, &amp;mut ctx);
    assert!(ctx.sys_buffer.pop().unwrap() == 5);
    assert!(ctx.sys_buffer.pop().unwrap() == 5);
}</code></pre>
<p>
For now I just added an object to hold anything that gets sent to the <code class="inline">.</code> command. I am not entirely happy with it. Ideally I’ll think I’ll have system calls handled by a separate struct, so that the core can be more test-friendly. This is a consequence of working off a C program which was intended to small and complete, without any testing focus.</p>
<p>
I am adding several of these types of tests for other primitives. The other major functionality is working with new words. First I wanted to cover some of the basic error cases.</p>
<pre><code class="rust">#[test]
#[should_panic]
fn undefined_word(){
    let mut ctx = Context::new();
    run_program(&quot;newword&quot;, &amp;mut ctx);
}</code></pre>
<p>
Just throwing a new word should panic. Defining a new word with no body should also panic:</p>
<pre><code class="rust">#[test]
#[should_panic]
fn new_word_no_body(){
    let mut ctx = Context::new();
    
    run_program(&quot;: square ;&quot;, &amp;mut ctx);
}</code></pre>
<p>
Next I used the zforth example definition as a basic test:</p>
<pre><code class="rust">#[test]
fn new_word(){
    let mut ctx = Context::new();
    
    // new word
    run_program(&quot;: square dup * ;&quot;, &amp;mut ctx);
    
    // run program with new word
    run_program(&quot;5 square .&quot;, &amp;mut ctx);
    
    assert!(ctx.sys_buffer.pop().unwrap() == 25);
}</code></pre>
<h2>
Basic demo</h2>
<p>
I added most of the base words and can add new words. I put a quick egui editor, and threw some syntax highlighting on. The project can be found here: <a href="https://github.com/485angelprocess/bbforth">GitHub - 485angelprocess/bbforth: small forth interpreter implemented in rust</a></p>
<p>
  <img src="../Resources/forth_editor.png" alt="forth editor">
</p>
<p>
Overall I’m happy with progress, it’s really nice thinking about forth works internally, and the decisions that make it simple and flexible to implement from a language perspective. Next I want to finish adding primitives, which will mean doing some memory access and return stack operations. I also want to improve the editor. I might make it more of a terminal prompt, but at least want to make it easy to read and self document well.</p>


    </div>
  </body>
</html>