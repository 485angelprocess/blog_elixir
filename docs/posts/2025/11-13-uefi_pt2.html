<html>
<head>
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/app.css">
  <script type="text/javascript" src="/assets/app.js"></script>
  <meta charset="UTF-8">
</head>
  <body>
    <div class="bg-linear-65 from-purple-500 to-pink-500">
    
  <a href="/../index.html">home</a>
  <h1>
UEFI Bootloader using nim</h1>
<p>
This is mostly following <a href="https://0xc0ffee.netlify.app/osdev">Fusion OS</a>. I’m interested in going through
to pick up both some os ideas and learn nim in a deeper way.</p>
<h2>
Entry point</h2>
<p>
We need a nim function which matches the UEFI specification’s entry point.
This can be done using the following nim code:</p>
<pre><code class="nim">import libc
import malloc

type
  EfiStatus = uint
  EfiHandle = pointer
  EFiSystemTable = object  # to be defined later

const
  EfiSuccess = 0

proc NimMain() {.importc.}

proc EfiMain(imgHandle: EfiHandle, sysTable: ptr EFiSystemTable): EfiStatus {.exportc.} =
  NimMain()
  return EfiSuccess</code></pre>
<p>
This reuses <code class="inline">libc</code> and <code class="inline">malloc</code>, from the previous post. The types here match the UEFI specification.
<code class="inline">NimMain</code> is also used to get the nim definitions.</p>
<h2>
UEFI firmware</h2>
<p>
QEMU defaults to a legacy BIOS, <code class="inline">ovmf</code> on ubuntu should cover it.</p>
<p>
For my machine I could run QEMU using ovmf:</p>
<pre><code class="bash">qemu-system-x86_64 \
  -machine q35 \
  -drive if=pflash,format=raw,readonly=on,file=/usr/share/ovmf/OVMF.fd \
  -drive format=raw,file=fat:rw:diskimg \
  -net none</code></pre>
<p>
This launches qemu with the q35 chipsets, and loads the firmware from ovmf. Older tutorials have separate
OVMF_VARS and OVMF_CODE, but for at least my setup those seem to be merged.
Qemu automatically looks in the <code class="inline">diskimg/efi/boot</code> folder for bootable programs.</p>
<p>
This runs correctly, opening a boot screen if my bootloader returns success, and crashes if it returns failure.</p>
<h2>
System Table</h2>
<p>
The system table was left as a stub, but I needed to define the whole structure, so now in <code class="inline">src/bootx64.nim</code>:</p>
<pre><code class="nim">type
  EfiStatus = uint

  EfiHandle = pointer

  EfiTableHeader = object
    signature: uint64
    revision: uint32
    headerSize: uint32
    crc32: uint32
    reserved: uint32

  EfiSystemTable = object
    header: EfiTableHeader
    firmwareVendor: WideCString
    firmwareRevision: uint32
    consoleInHandle: EfiHandle
    conIn: pointer
    consoleOutHandle: EfiHandle
    conOut: ptr SimpleTextOutputProtocol
    standardErrorHandle: EfiHandle
    stdErr: ptr SimpleTextOutputProtocol
    runtimeServices: pointer
    bootServices: pointer
    numTableEntries: uint
    configTable: pointer
  
  SimpleTextOutputProtocol = object
    reset: pointer
    outputString: proc (this: ptr SimpleTextOutputProtocol, str: WideCString): EfiStatus {.cdecl.}
    testString: pointer
    queryMode: pointer
    setMode: pointer
    setAttribute: pointer
    clearScreen: proc (this: ptr SimpleTextOutputProtocol): EfiStatus {.cdecl.}
    setCursorPos: pointer
    enableCursor: pointer
    mode: ptr pointer

const
  EfiSuccess = 0
  EfiLoadError = 1</code></pre>
<p>
This gives us access to the fields to get console in/out</p>
<h2>
Console out</h2>
<p>
Now in our main program we can manipulate the console. A good start is clearing the screen.</p>
<pre><code class="nim">proc EfiMain(imgHandle: EfiHandle, sysTable: ptr EfiSystemTable): EfiStatus {.exportc.} =
  NimMain()
  discard sysTable.conOut.clearScreen(sysTable.conOut)
  quit()</code></pre>
<p>
<code class="inline">quit</code> halts the CPU so that out program does not exit. This clears the screen correctly in qemu.</p>
<p>
Next I can add output:</p>
<pre><code class="nim">proc W*(str: string): WideCString =
  newWideCString(str).toWideCString

proc EfiMain(imgHandle: EfiHandle, sysTable: ptr EfiSystemTable): EfiStatus {.exportc.} = 
  NimMain()

  discard sysTable.conOut.clearScreen(sysTable.conOut)
  discard sysTable.conOut.outputString(sysTable.conOut, W&quot;hi :) welcome\n&quot;)
  quit()</code></pre>
<p>
The Fusion OS post mentions needing to explicitly set the <code class="inline">nimv2</code> flag. This is no longer neccessary, I’m running
nim verions 2.2.4.</p>
<p>
Next I moved the uefi structures to a separate file, and set the fields to public (<code class="inline">*</code> after a declaration sets it to public in nim).</p>
<p>
I added a variable <code class="inline">sysTable</code> which holds the uefi table. Then I added a few simple console commands:</p>
<pre><code class="nim">proc consoleClear*() =
  assert not sysTable.isNil
  discard sysTable.conOut.clearScreen(sysTable.conOut)

proc consoleOut*(str: string) =
  assert not sysTable.isNil
  discard sysTable.conOut.outputString(sysTable.conOut, W(str))

proc consoleError*(str: string) =
  assert not sysTable.isNil
  discard sysTable.stdErr.outputString(sysTable.stdErr, W(str))</code></pre>
<p>
Back in <code class="inline">libc.nim</code> I added a bit to <code class="inline">fwrite</code> so that it now works as expected (well until there are multiline outputs).</p>
<pre><code class="nim">proc fwrite*(buf: const_pointer, size: csize_t, count: csize_t, stream: File): csize_t {.exportc.} =
  let output = $cast[cstring](buf)
  consoleOut(output)
  return count</code></pre>
<p>
The main function is now:</p>
<pre><code class="nim">proc EfiMain(imgHandle: EfiHandle, sysTable: ptr EFiSystemTable): EfiStatus {.exportc.} =
  NimMain()
  uefi.sysTable = sysTable

  consoleClear()
  echo &quot;Hi welcome!&quot;

  quit()</code></pre>
<p>
This prints out nicely to the console :)</p>


    </div>
  </body>
</html>