<html>
<head>
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/app.css">
  <script type="text/javascript" src="/assets/app.js"></script>
  <meta charset="UTF-8">
</head>
  <body>
    <div class="bg-linear-65 from-purple-500 to-pink-500">
    
  <a href="/../index.html">home</a>
  <h1>
Getting UEFI support</h1>
<p>
This is the start of doing some OS work with nim. I’m using the really great documentation of <a href="https://0xc0ffee.netlify.app/osdev/">fusion os</a> as a starting point.</p>
<h2>
Getting UEFI with C</h2>
<p>
Since I’m interested in going through some of the work with Fusion OS, I am running an OS that has UEFI support. UEFI offers a unified interface for bootstrapping an OS.</p>
<p>
UEFI expected a PE32+ (portable executable with 64-bit extension). This is a format used by windows, but adopted by UEFI, so it’s something my OS has to follow. </p>
<p>
Fusion OS has a good overview of how to do this in C. A basic C program can be recognized as an PE32+ application. The clang command:</p>
<pre><code class="bash">$ clang \
    -target x86_64-unknown-windows \
    -fuse-ld=lld-link \
    -nostdlib \
    -Wl,-entry:main \
    -Wl,-subsystem:efi_application \
    -o build/main.exe \
    build/main.o</code></pre>
<p>
This has the <code class="inline">no-std flag</code>, explicitly sets the main entry and acts the compiler to make it a UEFI application.</p>
<p>
To check the file format:</p>
<pre><code>file build/main.exe</code></pre>
<h2>
UEFI with nim</h2>
<p>
I start with a minimal nim function:</p>
<pre><code class="nim">proc main(): int {.exportc.} =
    return 0</code></pre>
<p>
<code class="inline">{.exportc.}</code> is a pragma which tells nim explicitly not to mangle the function name.</p>
<p>
The nim build command:</p>
<pre><code class="bash">$ nim c \
    --nimcache:build \
    --cpu:amd64 \
    --os:any \
    --cc:clang \
    --passc:&quot;-target x86_64-unknown-windows&quot; \
    --passc:&quot;-ffreestanding&quot; \
    --passl:&quot;-fuse-ld=lld-link&quot; \
    --passl:&quot;-nostdlib&quot; \
    --passl:&quot;-Wl,-entry:main&quot; \
    --passl:&quot;-Wl,-subsystem:efi_application&quot; \
    --out:build/main.exe \
    src/main.nim</code></pre>
<p>
This uses a few flags to correclty route nim how we want. The cpu is set as <code class="inline">amd64</code>, the os needs to be set as <code class="inline">any</code> so that is not built as a linux application. <code class="inline">clang</code> is set as the the compiler, which can do uefi instead of <code class="inline">gcc</code>.</p>
<p>
As pointed out in the Fusion OS documentation, this gives a memory error. Essentially nim doesn’t know what the <code class="inline">malloc</code> function is if there’s no OS specified.</p>
<p>
I have to give nim the explicit memory management functions.</p>
<pre><code class="nim"># malloc.nim

{.used.}

var
  heap*: array[1*1024*1024, byte] # 1 MiB heap
  heapBumpPtr*: int = cast[int](addr heap)
  heapMaxPtr*: int = cast[int](addr heap) + heap.high

proc malloc*(size: csize_t): pointer {.exportc.} =
  if heapBumpPtr + size.int &gt; heapMaxPtr:
    return nil

  result = cast[pointer](heapBumpPtr)
  inc heapBumpPtr, size.int

proc calloc*(num: csize_t, size: csize_t): pointer {.exportc.} =
  result = malloc(size * num)
  
proc free*(p: pointer) {.exportc.} =
  discard

proc realloc*(p: pointer, new_size: csize_t): pointer {.exportc.} =
  result = malloc(new_size)
  copyMem(result, p, new_size)
  free(p)</code></pre>
<p>
The <code class="inline">{.used.}</code> pragma tells nim that this code is relevant. Otherwise it would be thrown out since the functions are not explicitly called.</p>
<p>
Aside: I had to rearrange the function declarations, to put <code class="inline">free</code> up so that it is declared before the definition of <code class="inline">realloc</code>. I’m not sure if this is some quirk, or if nim does have required order (it really feels like a language that wouldn’t).</p>
<p>
I then needed to link clang to system libraries for some build tools by adding <code class="inline">--passc:&quot;-I/usr/include&quot; \</code> to the nim flags. I then got an error showing that <code class="inline">&lt;bits/libc-header-start.h&gt;</code> was missing. I used <code class="inline">$ dpkg -S /usr/include/bits</code> to find the missing package which was <code class="inline">libc6-dev-i386</code>.</p>
<p>
The next error is nim finding a conflicing main function. This is solved by adding the <code class="inline">--noMain:on</code> flag, and adding a <code class="inline">proc NimMain()</code> to the main proc. My main file is now:</p>
<pre><code class="nim">import malloc

proc NimMain() {.importc.}

proc main(): int{.exportc.} =
    NimMain()
    return 0</code></pre>
<p>
Now we get a series of errors which are asking for definitions of POSIX functions. Since I’m learning through how Fusion OS set this up, I am going to ignore some of these, but want to bookmark this step, since I may return to add some form of POSIX utility.</p>
<h2>
Filling in missing functions</h2>
<p>
Nim still needs a few functions to be explicitly defined. <code class="inline">fwrite</code>, <code class="inline">fflush</code>, <code class="inline">stdout</code> and <code class="inline">exit</code>.</p>
<p>
<code class="inline">fwrite</code> writes to a function, we can define a template (in <code class="inline">src/libc.nim</code>):</p>
<pre><code>type
    const_pointer {.importc: &quot;const void *&quot;.} = pointer
    
proc fwrite*(ptr: const_pointer, size: csize_t, count: csize_t, stream: File):
    csize_t {.exportc.} =
    return count</code></pre>
<p>
This is a nice example of nim’s ability to do metaprogramming, nim does not define <code class="inline">const void *</code> which is needed by the function template, but we can simply give it the needed C definition and it will keep rolling. One thing that I notice here, is I’m following someone else’s notes, so I know that <code class="inline">File</code> is defined, but I wouldn’t have that off the top of my head. nim’s documentation is not so amazing that I’d know what I didn’t know in that regard.</p>
<p>
Also still being used is the <code class="inline">.exportc.</code> macro which is preventing mangling.</p>
<p>
The other function templates:</p>
<pre><code># fflush: flushes the stream
proc fflush*(stream: File): cint {.exportc.} =
  return 0.cint
  
# stdout and stderr
# global variables with the file struct
var
    stdout* {.exportc.}: File
    stderr* {.exportc.}: File
    
# exit function
proc exit*(status: cint) {.exportc, asmNoStackFrame.} =
    asm &quot;&quot;&quot;
    .loop:
        cli
        hlt
        jmp .loop
    &quot;&quot;&quot;</code></pre>
<p>
The exit function is done with inline assembly, since the exit function can’t return to any OS program. My libc can be imported in my main function, although it also requires the <code class="inline">{.used.}</code> pragma, since the functions aren’t called.</p>
<p>
The <code class="inline">{.asmNoStackFrame.}</code> tells the compiler not to put a stack frame around the asm code. I have only ever written just pure assembly, or flippantly was adding asm to C code every once in a while, so this is the most I’ve thought of how exaclty C handles inline asm. Dusk OS uses reserved registers in a similar way, which is a nice connection to make.</p>
<p>
With this all together, I can at least compile to a PE32+ executable. I’m going to take a break for now, but next will be getting a UEFI bootloader.s</p>


    </div>
  </body>
</html>