<html>
<head>
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/app.css">
  <script type="text/javascript" src="/assets/app.js"></script>
</head>
  <body>
    <div class="bg-linear-65 from-purple-500 to-pink-500">
    
  <a href="/../index.html">home</a>
  <h1>
Framebuffer using Amaranth HDL and Vivado MIG-7</h1>
<p>
Framebuffers are commonly needed for any type of video processing. A framebuffer is simply a collection of pixel data (i.e. a frame of video) which can be read as a stream and written to asynchronously. Framebuffers are useful whenever the incoming data is not already rasterized, or pixels are not ordered line by line, or when the data in is not constantly refreshing every pixel. This occurs if during video decoding, which is generally not rasterized, and on most frames only some pixels are written to.</p>
<p>
Vivado’s MIG-7 is a memory controller for DDR3 Ram, on hardware with ram it simplifies a large number of processes. It allows for direct memory access using an AXI-4 protocol. The main process is to make a module that can abstract interface to make frame management easy, and to have the desired input and output interface. For this example, I’m going to make a wishbone interface for direct reading and writing and a stream output interface using the AXIS protocol. I also want my module to have a control bus, also using wishbone to select frame size and frame selection.</p>
<h2>
Interfaces</h2>
<p>
I start by defining the signatures that will be used. All the interfaces use the amaranth imports:</p>
<pre><code class="python">from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out</code></pre>
<p>
AXI4 is defined by arm, this is a minimal master interface. Addresses and data have their own handshakes, and the bus must finish a response transaction after a write has finished. The <code class="inline">len</code> parameter gives the downstream component information about how many transactions there will be. The <code class="inline">size</code> component gives information about how wide each transaction is. AXI4 has some redundancy built in, which allows for some flexibility, but I’ve found that there’s often some issues with mismatching implementations. But, it’s what AMD/Xilinx decided to build into Vivado blocks, so it has to get used. Here is a AXI4 master interface in amaranth:</p>
<pre><code class="python">class Axi4(wiring.Signature):
    def __init__(self, addr_shape, data_shape):
        super().__init__({
            # Write address
            &quot;awaddr&quot;: Out(addr_shape),
            &quot;awvalid&quot;: Out(1),
            &quot;awready&quot;: In(1),
            &quot;awlen&quot;: Out(8),
            &quot;awsize&quot;: Out(3),

            # Write data
            &quot;wdata&quot;: Out(data_shape),
            &quot;wlast&quot;: Out(1),
            &quot;wstrb&quot;: Out(4),
            &quot;wvalid&quot;: Out(1),
            &quot;wready&quot;: In(1),

            # Read address
            &quot;araddr&quot;: Out(addr_shape),
            &quot;arlen&quot;: Out(8),
            &quot;arsize&quot;: Out(3),
            &quot;arvalid&quot;: Out(1),
            &quot;arready&quot;: In(1),

            # Read data
            &quot;rdata&quot;: In(data_shape),
            &quot;rlast&quot;: In(1),
            &quot;rvalid&quot;: In(1),
            &quot;rready&quot;: Out(1),

            # Response
            &quot;bresp&quot;: In(2),
            &quot;bvalid&quot;: In(1),
            &quot;bready&quot;: Out(1)
        })</code></pre>
<p>
AXIS is a related standard which is used for data streams. At some point in the video processing pipeline, I will want video in rasterized order as a stream. Here I’m taking it from the framebuffer. An AXIS stream carries data, with a valid flag and a ready flag for backflow control. Additionally the <code class="inline">last</code> and <code class="inline">user</code> signal are used to indicate hsync and vsync.</p>
<pre><code class="python">class Axis(wiring.Signature):
    def __init__(self, data_shape, user_shape = 1):
        super().__init__({
            &quot;tdata&quot;: Out(data_shape),
            &quot;tvalid&quot;: Out(1),
            &quot;tready&quot;: In(1),
            &quot;tuser&quot;: Out(user_shape),
            &quot;tlast&quot;: In(1)
        })</code></pre>
<p>
While there is a built-in amaranth interface for streams, I want to explicitly use the same naming conventions as Vivado, as it simplifies integrating into their block system.</p>
<p>
Finally wishbone is a open source framework for bus ports, this is a simple implementation for single reads and writes. This is not setting up for high throughput direct reads/writes, but I can add to it later. I mostly know that I am setting up projects which use this port structure for its simplicity to implement. For a higher throughput system, building in capability for bursts will improve ram performance.</p>
<pre><code class="python">class Wishbone(wiring.Signature):
    def __init__(self, addr_shape, data_shape):
        super().__init__({
            &quot;addr&quot;: Out(addr_shape),

            &quot;stb&quot;: Out(1),
            &quot;cyc&quot;: Out(1),
            &quot;ack&quot;: In(1),

            &quot;w_data&quot;: Out(data_shape),
            &quot;w_enable&quot;: Out(1),

            &quot;r_data&quot;: In(data_shape)
        })</code></pre>
<p>
Now that I have my interfaces setup, most of the work is connecting things together, and getting some tests up and running.</p>
<h2>
Testing</h2>
<p>
To run tests, I want to set up some helpful functions to make tests easy to write and to understand. I have made a earlier post about writing this type of function for single wishbone single transactions. I am going to reuse those functions, and add some for the AXI interfaces. For AXI4, I want to be able to simulate write functions using the Amaranth simulation framework. This looks like this:</p>
<pre><code class="python">async def axi_write(ctx, port, addr, size, length, data):

    # Writes address first and then writes data
    # This misses case of simultaneous address and data write

    # Write address
    ctx.set(port.awvalid, 1)
    ctx.set(port.awaddr, addr)
    ctx.set(port.awsize, size)
    ctx.set(port.awlen, length)

    await ctx.tick().until(port.awready)

    # Finish write address
    ctx.set(port.awvalid, 0)

    # Start write data
    ctx.set(port.wvalid, 1)

    for i in range(len(data)):
        ctx.set(port.wdata, data[i])
        ctx.set(port.wlast, i == len(data) - 1) # Last flag
        await ctx.tick().until(port.wready)

    # End write data
    ctx.set(port.wvalid, 0)

    # Response
    ctx.set(port.bready, 1)

    await ctx.tick().until(port.bvalid)

    # Valid response
    assert ctx.get(port.bresp) == 0

    return</code></pre>
<p>
This writes the address, then writes a number of values, and then checks the response.  A thing that should also be checked is changing the delay between transactions, especially the case where the address and data transactions are started simultaneously, and when there is a delay greater than 1 clock cycle.</p>
<p>
An AXI read is similar:</p>
<pre><code class="python">async def axi_read(ctx, port, addr, size, length):
    # Write read address
    ctx.set(port.arvalid, 1)
    ctx.set(port.araddr, addr)
    ctx.set(port.arsize, size)
    ctx.set(port.arlen, length)

    await ctx.tick().until(port.arready)

    # Finish read address
    ctx.set(port.arvalid, 0)

    data = list()

    # Read data
    while True:
        ctx.set(port.rready, 1)
        d, last = await ctx.tick().sample(port.rdata, port.rlast).until(port.rvalid)
        data.append(d)
        if last:
            ctx.set(port.rready, 0)
            return data</code></pre>
<p>
For the AXIS stream, I only need to read the result. This just means setting the ready flag and waiting for valid data.</p>
<pre><code class="python">async def axis_read(ctx, port):
    ctx.set(port.tready, 1)
    await ctx.tick().until(port.tvalid)
    data = ctx.get(port.tdata)
    user = ctx.get(port.tuser)
    last = ctx.get(port.tlast)
    ctx.set(port.tready, 0)
    return data, user, last</code></pre>
<p>
Finally, some wishbone utilities:</p>
<pre><code class="python">async def wishbone_write(ctx, port, addr, data):
    ctx.set(port.stb, 1)
    ctx.set(port.cyc, 1)
    ctx.set(port.addr, addr)
    ctx.set(port.w_data, data)
    ctx.set(port.w_enable, 1)

    await ctx.tick().until(port.ack)

    ctx.set(port.stb, 0)
    ctx.set(port.cyc, 0)
    ctx.set(port.w_enable, 0)

async def wishbone_read(ctx, port, addr):
    ctx.set(port.stb, 1)
    ctx.set(port.cyc, 1)
    ctx.set(port.addr, addr)
    ctx.set(port.w_enable, 0)
    
    data, = await ctx.tick().sample(port.r_data).until(port.ack)
    
    ctx.set(port.stb, 0)
    ctx.set(port.cyc, 0)
    
    return data</code></pre>
<p>
What I started with is making a mock mig device to test against. There is also the AXI verification tool in Vivado, which I’ll be using later. But for now, it’s easier to stay within amaranth, while working on functional components. I wrote some sanity tests to make sure my ram device works as expected. These are very simple, but it’s a headache to check back if the mock device works when doing later tests.</p>
<pre><code class="python">class TestMockMem(unittest.TestCase):
    &quot;&quot;&quot;
    Sanity tests for my fake memory device
    &quot;&quot;&quot;
    def dut(self):
        return MockRam()

    def test_short(self):
        dut = self.dut()

        async def process(ctx):
            await axi_write(ctx, dut.axi, addr = 0, size = 0, length = 0, data = [10])
            assert await axi_read(ctx, dut.axi, addr = 0, size = 0, length = 0) == [10]

            await axi_write(ctx, dut.axi, addr = 1, size = 0, length = 0, data = [11])
            assert await axi_read(ctx, dut.axi, addr = 1, size = 0, length = 0) == [11]

            await axi_write(ctx, dut.axi, addr = 2, size = 0, length = 0, data = [13])
            assert await axi_read(ctx, dut.axi, addr = 0, size = 0, length = 0) == [10]
            assert await axi_read(ctx, dut.axi, addr = 2, size = 0, length = 0) == [13]

        sim = Simulator(dut)
        sim.add_clock(1e-8)
        sim.add_testbench(process)

        with sim.write_vcd(&quot;bench/test_mock_mem_short.vcd&quot;) as vcd:
            sim.run()

    def test_long(self):
        dut = self.dut()

        async def process(ctx):
            await axi_write(ctx, dut.axi, addr = 0, size = 2, length = 1, data = [
                0xAABBCCDD, 0xEEFF0011
            ])
            result = await axi_read(ctx, dut.axi, addr = 0, size = 2, length = 1)
            #print(&quot;Result = {}&quot;.format(&quot; &quot;.join([&quot;0x{:08X}&quot;.format(r) for r in result])))
            assert result == [0xAABBCCDD, 0xEEFF0011]

            await axi_write(ctx, dut.axi, addr = 8, size = 2, length = 1, data = [
                0xBBAAEEFF, 0x33221155
            ])

            result = await axi_read(ctx, dut.axi, addr = 0, size = 2, length = 3)
            assert result == [0xAABBCCDD, 0xEEFF0011, 0xBBAAEEFF, 0x33221155]

        sim = Simulator(dut)
        sim.add_clock(1e-8)
        sim.add_testbench(process)

        with sim.write_vcd(&quot;bench/test_mock_mem_long.vcd&quot;) as vcd:
            sim.run()</code></pre>
<p>
Handling the size and length constraints for AXI always makes modules a little goofy looking, but as long as I have a reference for functioning, I can always go back and make improvements.</p>


    </div>
  </body>
</html>