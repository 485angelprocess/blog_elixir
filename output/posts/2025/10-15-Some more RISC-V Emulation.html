<html>
<head>
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/app.css">
  <script type="text/javascript" src="/assets/app.js"></script>
</head>
  <body>
    <div class="bg-linear-65 from-purple-500 to-pink-500">
    
  <a href="/../index.html">home</a>
  <h1>
Some more RISC-V Emulation</h1>
<p>
I am still looking into understanding risc-v a bit more, this will be a little scattershot. First I was looking at understanding <a href="https://github.com/noteed/riscv-hello-c/tree/master">noteed/riscv-hello</a>. This uses just a few features of the <a href="https://github.com/michaeljclark/riscv-probe/tree/master/libfemto/std">libfemto</a> So this starts by creating a minimal UART driver. The header file just defines one function, and runs in C.</p>
<p>
This is <code class="inline">stdio.h</code></p>
<pre><code class="cpp">#pragma once

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

int putchar(int);

#ifdef __cplusplus
}
#endif</code></pre>
<p>
Then they build the the driver by setting the address of UART in memory (in this case <code class="inline">0x10013000</code>). If waits for the uart register to be available. and then writes the char to the register location.</p>
<pre><code class="c">// See LICENSE for license details.

#include &lt;stdio.h&gt;

enum {
    /* UART Registers */
    UART_REG_TXFIFO = 0,
};

static volatile int *uart = (int *)(void *)0x10013000;

int putchar(int ch)
{
    while (uart[UART_REG_TXFIFO] &lt; 0);
    return uart[UART_REG_TXFIFO] = ch &amp; 0xff;
}</code></pre>
<p>
Next there is a small wrapper function, which actually calls main.</p>
<pre><code class="c">void main();

void libfemto_start_main(){
    main();
}</code></pre>
<p>
The actual main function creates a char array and pushes it out one character at a time, and then loops forever.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

void main(){
    const char *s = &quot;Hello\n&quot;;
    while (*s) putchar(*s++);
    while(1);
}</code></pre>
<p>
There are two more files. One is the C runtime file which jumps to the main of the actual program. The default one that gcc pulls is not correct so we have to override it.</p>
<pre><code class="c"># See LICENSE for license details.

.section .text.init,&quot;ax&quot;,@progbits
.globl _start

_start:
    j       main</code></pre>
<p>
Then define the memory layout of the program. </p>
<pre><code class="c">MEMORY
{
  ram   (wxa!ri) : ORIGIN = 0x80000000, LENGTH = 128M
}

PHDRS
{
  text PT_LOAD;
  data PT_LOAD;
  bss PT_LOAD;
}

SECTIONS
{
  .text : {
    PROVIDE(_text_start = .);
    *(.text.init) *(.text .text.*)
    PROVIDE(_text_end = .);
  } &gt;ram AT&gt;ram :text

  .rodata : {
    PROVIDE(_rodata_start = .);
    *(.rodata .rodata.*)
    PROVIDE(_rodata_end = .);
  } &gt;ram AT&gt;ram :text

  .data : {
    . = ALIGN(4096);
    PROVIDE(_data_start = .);
    *(.sdata .sdata.*) *(.data .data.*)
    PROVIDE(_data_end = .);
  } &gt;ram AT&gt;ram :data

  .bss :{
    PROVIDE(_bss_start = .);
    *(.sbss .sbss.*) *(.bss .bss.*)
    PROVIDE(_bss_end = .);
  } &gt;ram AT&gt;ram :bss

  PROVIDE(_memory_start = ORIGIN(ram));
  PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram));
}</code></pre>
<p>
I found a good breakdown of the linker file at <a href="https://allthingsembedded.com/post/2020-04-11-mastering-the-gnu-linker-script/">Mastering the GNU linker script - AllThingsEmbedded</a>.The <code class="inline">MEMORY</code> section sets the ram origin to the boot location. Then it sets the Program Headers(<code class="inline">PHDRS</code>), these descrive how the program should be loaded into memory. Some more info on that section <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_23.html">here</a>. Then it describes the sections of memory in <code class="inline">SECTION</code> . There are 4 sections used here.</p>
<ul>
  <li>
    <p>
<code class="inline">.text</code> section that contains the code. This is loaded at the text program directory location.    </p>
  </li>
  <li>
    <p>
<code class="inline">.rodata</code> contains read only data. This is overlapping the <code class="inline">.text</code> section, the code shouldn’t be modifying itself.    </p>
  </li>
  <li>
    <p>
<code class="inline">.data</code> contains initilalized global and static variables, which in this case should just be the UART register address.    </p>
  </li>
  <li>
    <p>
<code class="inline">.bss</code> these are unitialized global and static variables. In most cases these will be initialized to zero, but not always in embedded systems.    </p>
  </li>
</ul>


    </div>
  </body>
</html>